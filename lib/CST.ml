(* Generated by ocaml-tree-sitter. *)
(*
   gosu grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type decimal_floating_point_literal = Token.t

type pat_22cdef7 = Token.t (* pattern "\"([^\"\\\\]|\\\\\")*" *)

type hex_floating_point_literal = Token.t

type character_literal = Token.t

type hex_integer_literal = Token.t

type binary_integer_literal = Token.t

type anon_choice_as_0eafe76 = [
    `As of Token.t (* "as" *)
  | `Typeas of Token.t (* "typeas" *)
]

type escape_sequence = Token.t

type tok_choice_dotdot = Token.t

type pat_3a2a380 = Token.t (* pattern "[^\"\\\\]+" *)

type decimal_integer_literal = Token.t

type identifier = Token.t (* pattern [A-Za-z_$][A-Za-z0-9_$]* *)

type requires_modifier = [
    `Tran of Token.t (* "transitive" *)
  | `Static of Token.t (* "static" *)
]

type string_fragment = Token.t (* pattern "[^\"\\\\]+" *)

type integral_type = [
    `Byte of Token.t (* "byte" *)
  | `Short of Token.t (* "short" *)
  | `Int of Token.t (* "int" *)
  | `Long of Token.t (* "long" *)
  | `Char of Token.t (* "char" *)
]

type octal_integer_literal = Token.t

type floating_point_type = [
    `Float of Token.t (* "float" *)
  | `Double of Token.t (* "double" *)
]

type tok_plusplus = Token.t

type imm_tok_bslash_pat_e8ee8e5 = Token.t

type infinity_literal = Token.t

type tok_dashdash = Token.t

type nan_literal = Token.t

type automatic_semicolon = Token.t

type anon_choice_fore_b3b5f65 = [
    `Fore of Token.t (* "foreach" *)
  | `For of Token.t (* "for" *)
]

type multiline_string_fragment = [
    `Pat_3a2a380 of pat_3a2a380
  | `Pat_22cdef7 of pat_22cdef7
]

type anon_opt_choice_as_opt_read_id_3ff203e =
  (
      anon_choice_as_0eafe76
    * Token.t (* "readonly" *) option
    * identifier (*tok*)
  )
    option

type catch_formal_parameter = (
    identifier (*tok*)
  * (Token.t (* ":" *) * identifier (*tok*)) option
)

type name = [
    `Id of identifier (*tok*)
  | `Scoped_id of (name * Token.t (* "." *) * identifier (*tok*))
]

type anon_choice_id_fb82200 = [
    `Id of identifier (*tok*)
  | `Unde_pat of Token.t (* "_" *)
]

type iteratorvar = (Token.t (* "iterator" *) * identifier (*tok*))

type indexvar = (Token.t (* "index" *) * identifier (*tok*))

type escape_sequence_ = [
    `Imm_tok_bslash_pat_e8ee8e5 of imm_tok_bslash_pat_e8ee8e5
  | `Esc_seq of escape_sequence (*tok*)
]

type semicolon = [
    `Auto_semi of automatic_semicolon (*tok*)
  | `SEMI of Token.t (* ";" *)
]

type anon_to_name_rep_COMMA_name_2956291 = (
    Token.t (* "to" *)
  * name
  * (Token.t (* "," *) * name) list (* zero or more *)
)

type indexrest = [
    `Inde_opt_iter of (indexvar * iteratorvar option)
  | `Iter_opt_inde of (iteratorvar * indexvar option)
]

type annotation = [
    `Marker_anno of (Token.t (* "@" *) * name)
  | `Anno_ of annotation_
]

and annotation_ = (Token.t (* "@" *) * name * annotation_argument_list)

and annotation_argument_list = (
    Token.t (* "(" *)
  * [
        `Elem_value of element_value
      | `Opt_elem_value_pair_rep_COMMA_elem_value_pair of
          (
              element_value_pair
            * (Token.t (* "," *) * element_value_pair)
                list (* zero or more *)
          )
            option
    ]
  * Token.t (* ")" *)
)

and annotation_type_body = (
    Token.t (* "{" *)
  * [
        `Anno_type_elem_decl of annotation_type_element_declaration
      | `Cst_decl of constant_declaration
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `Enum_decl of enum_declaration
      | `Anno_type_decl of annotation_type_declaration
      | `SEMI of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and annotation_type_declaration = (
    modifiers option
  * Token.t (* "@interface" *)
  * identifier (*tok*)
  * annotation_type_body
)

and annotation_type_element_declaration = (
    modifiers option
  * unannotated_type
  * identifier (*tok*)
  * Token.t (* "(" *)
  * Token.t (* ")" *)
  * dimensions option
  * default_value option
  * Token.t (* ";" *)
)

and anon_choice_fnpa_01ea645 = [
    `Fnpa of fnparameterdeclaration
  | `Blk_lit_id of block_literal_identifier
]

and anon_choice_record_pat_comp_a91ed66 = [
    `Record_pat_comp of record_pattern_component
  | `Record_pat of record_pattern
]

and anon_choice_type_205a2ac = [
    `Type of type_
  | `Wild of (
        annotation list (* zero or more *)
      * Token.t (* "?" *)
      * wildcard_bounds option
    )
]

and anon_var_init_rep_COMMA_var_init_6e00f52 = (
    variable_initializer
  * (Token.t (* "," *) * variable_initializer) list (* zero or more *)
)

and argument_list = (
    Token.t (* "(" *)
  * anon_var_init_rep_COMMA_var_init_6e00f52 option
  * Token.t (* ")" *)
)

and array_access = (
    primary_expression
  * Token.t (* "?" *) option
  * Token.t (* "[" *)
  * expression
  * Token.t (* "]" *)
)

and array_initializer = (
    Token.t (* "{" *)
  * anon_var_init_rep_COMMA_var_init_6e00f52 option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and assert_statement = [
    `Assert_exp_semi of (Token.t (* "assert" *) * expression * semicolon)
  | `Assert_exp_COLON_exp_semi of (
        Token.t (* "assert" *) * expression * Token.t (* ":" *) * expression
      * semicolon
    )
]

and binary_expression = [
    `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_EQEQEQ_exp of (expression * Token.t (* "===" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_LTGT_exp of (expression * Token.t (* "<>" *) * expression)
  | `Exp_and_exp of (expression * Token.t (* "and" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_or_exp of (expression * Token.t (* "or" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_QMARKPLUS_exp of (expression * Token.t (* "?+" *) * expression)
  | `Exp_BANGPLUS_exp of (expression * Token.t (* "!+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_QMARKDASH_exp of (expression * Token.t (* "?-" *) * expression)
  | `Exp_BANGDASH_exp of (expression * Token.t (* "!-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_QMARKSTAR_exp of (expression * Token.t (* "?*" *) * expression)
  | `Exp_BANGSTAR_exp of (expression * Token.t (* "!*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_QMARKSLASH_exp of (expression * Token.t (* "?/" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_QMARKPERC_exp of (expression * Token.t (* "?%" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
]

and block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and block_definition_expression = (
    Token.t (* "\\" *)
  * identifier (*tok*)
  * (Token.t (* ":" *) * unannotated_type) option
  * (
        Token.t (* "," *)
      * identifier (*tok*)
      * (Token.t (* ":" *) * unannotated_type) option
    )
      list (* zero or more *)
  * Token.t (* "->" *)
  * [ `Exp of expression | `Blk of block ]
)

and block_literal_identifier = (
    identifier (*tok*)
  * fnparameters
  * Token.t (* ":" *)
  * unannotated_type
  * (Token.t (* "=" *) * expression) option
)

and cast_expression = [
    `LPAR_type_RPAR_exp of (
        Token.t (* "(" *) * type_ * Token.t (* ")" *) * expression
    )
  | `Exp_choice_as_type of (expression * anon_choice_as_0eafe76 * type_)
  | `LPAR_type_rep_AMP_type_RPAR_choice_prim_exp of (
        Token.t (* "(" *)
      * type_
      * (Token.t (* "&" *) * type_) list (* zero or more *)
      * Token.t (* ")" *)
      * [
            `Prim_exp of primary_expression
          | `Blk_defi_exp of block_definition_expression
        ]
    )
]

and catch_clause = (
    Token.t (* "catch" *) * Token.t (* "(" *) * catch_formal_parameter
  * Token.t (* ")" *) * block
)

and class_body = (
    Token.t (* "{" *)
  * class_body_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and class_body_declaration = [
    `Field_decl of (
        modifiers option
      * Token.t (* "var" *)
      * variable_declarator
      * semicolon
    )
  | `Prop_decl of (
        modifiers option
      * Token.t (* "property" *)
      * [ `Get of Token.t (* "get" *) | `Set of Token.t (* "set" *) ]
      * identifier (*tok*)
      * fnparameters
      * (Token.t (* ":" *) * unannotated_type) option
      * block
    )
  | `Meth_decl of method_declaration
  | `Class_decl of class_declaration
  | `Inte_decl of interface_declaration
  | `Enum_decl of enum_declaration
  | `Static_init of (Token.t (* "static" *) * block)
  | `Cons_decl of (
        Token.t (* "construct" *) * formal_parameters * constructor_body
    )
  | `Dele_decl of (
        Token.t (* "delegate" *) * identifier (*tok*)
      * Token.t (* "represents" *) * identifier (*tok*)
    )
  | `SEMI of Token.t (* ";" *)
]

and class_declaration = (
    modifiers option
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * superclass option
  * super_interfaces option
  * permits option
  * class_body
)

and constant_declaration = (
    modifiers option
  * Token.t (* "var" *)
  * variable_declarator
  * semicolon
)

and constructor_body = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and declaration = [
    `Pack_decl of (
        annotation list (* zero or more *)
      * Token.t (* "package" *)
      * name
      * semicolon
    )
  | `Clas_decl of (
        Token.t (* "classpath" *) * Token.t (* "\"" *) * name
      * Token.t (* "\"" *) * semicolon
    )
  | `Uses_decl of (
        Token.t (* "uses" *)
      * Token.t (* "static" *) option
      * name
      * (Token.t (* "." *) * Token.t (* "*" *)) option
      * semicolon
    )
  | `Class_decl of class_declaration
  | `Inte_decl of interface_declaration
  | `Anno_type_decl of annotation_type_declaration
  | `Enum_decl of enum_declaration
]

and default_value = (Token.t (* "default" *) * element_value)

and dimensions =
  (
      annotation list (* zero or more *)
    * Token.t (* "[" *)
    * Token.t (* "]" *)
  )
    list (* one or more *)

and dimensions_expr = (
    annotation list (* zero or more *)
  * Token.t (* "[" *)
  * expression
  * Token.t (* "]" *)
)

and element_value = [
    `Exp of expression
  | `Elem_value_array_init of (
        Token.t (* "{" *)
      * (
            element_value
          * (Token.t (* "," *) * element_value) list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Anno of annotation
]

and element_value_pair = (
    identifier (*tok*) * Token.t (* "=" *) * element_value
)

and enum_body = (
    Token.t (* "{" *)
  * (
        enum_constant
      * (Token.t (* "," *) * enum_constant) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and enum_constant = (
    modifiers option
  * identifier (*tok*)
  * argument_list option
  * class_body option
)

and enum_declaration = (
    modifiers option
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * enum_body
)

and expression = [
    `Bin_exp of binary_expression
  | `Prim_exp of primary_expression
  | `Assign_exp of (
        [
            `Id of identifier (*tok*)
          | `Field_access of field_access
          | `Array_access of array_access
        ]
      * [
            `EQ of Token.t (* "=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `AMPAMPEQ of Token.t (* "&&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `BARBAREQ of Token.t (* "||=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
        ]
      * variable_initializer
    )
  | `Typeis_exp of (
        expression
      * Token.t (* "typeis" *)
      * Token.t (* "final" *) option
      * [
            `Type_opt_id of (type_ * identifier (*tok*) option)
          | `Record_pat of record_pattern
        ]
    )
  | `Blk_defi_exp of block_definition_expression
  | `Tern_exp of ternary_expression
  | `Update_exp of update_expression
  | `Un_exp of unary_expression
  | `Cast_exp of cast_expression
  | `Switch_exp of switch_expression
  | `Type_lit_exp of (
        [
            `Typeof of Token.t (* "typeof" *)
          | `Stat of Token.t (* "statictypeof" *)
        ]
      * parenthesized_expression
    )
]

and expression_statement = (expression * semicolon)

and extends_interfaces = (Token.t (* "extends" *) * type_list)

and field_access = (
    [ `Prim_exp of primary_expression | `Super of Token.t (* "super" *) ]
  * [
        `DOT of Token.t (* "." *)
      | `QMARKDOT of Token.t (* "?." *)
      | `STARDOT of Token.t (* "*." *)
    ]
  * [ `Id of identifier (*tok*) | `This of Token.t (* "this" *) ]
)

and finally_clause = (Token.t (* "finally" *) * block)

and fnparameterdeclaration = (
    annotation_ list (* zero or more *) option
  * Token.t (* "final" *) option
  * identifier (*tok*)
  * (Token.t (* ":" *) * unannotated_type) option
  * (Token.t (* "=" *) * expression) option
)

and fnparameters = (
    Token.t (* "(" *)
  * (
        anon_choice_fnpa_01ea645
      * (Token.t (* "," *) * anon_choice_fnpa_01ea645)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and formal_parameter = (
    variable_declarator_id
  * [
        `COLON_unan_type_opt_EQ_exp of (
            Token.t (* ":" *)
          * unannotated_type
          * (Token.t (* "=" *) * expression) option
        )
      | `EQ_exp of (Token.t (* "=" *) * expression)
    ]
)

and formal_parameters = (
    Token.t (* "(" *)
  * (
        formal_parameter
      * (Token.t (* "," *) * formal_parameter) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and generic_type = (
    [ `Id of identifier (*tok*) | `Scoped_type_id of scoped_type_identifier ]
  * type_arguments
)

and guard = (Token.t (* "when" *) * expression)

and interface_body = (
    Token.t (* "{" *)
  * [
        `Cst_decl of constant_declaration
      | `Enum_decl of enum_declaration
      | `Meth_defi of method_defination
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `Anno_type_decl of annotation_type_declaration
      | `SEMI of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and interface_declaration = (
    modifiers option
  * Token.t (* "interface" *)
  * identifier (*tok*)
  * type_parameters option
  * extends_interfaces option
  * permits option
  * interface_body
)

and literal = [
    `Deci_int_lit of decimal_integer_literal (*tok*)
  | `Hex_int_lit of hex_integer_literal (*tok*)
  | `Octal_int_lit of octal_integer_literal (*tok*)
  | `Bin_int_lit of binary_integer_literal (*tok*)
  | `Deci_floa_point_lit of decimal_floating_point_literal (*tok*)
  | `Hex_floa_point_lit of hex_floating_point_literal (*tok*)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `Char_lit of character_literal (*tok*)
  | `Str_lit of string_literal
  | `Null_lit of Token.t (* "null" *)
  | `Infi_lit of infinity_literal (*tok*)
  | `Nan_lit of nan_literal (*tok*)
]

and localvarstatement = (
    Token.t (* "var" *)
  * anon_choice_id_fb82200
  * [
        `COLON_type_opt_choice_as_opt_read_id_opt_EQ_exp of (
            Token.t (* ":" *)
          * type_
          * anon_opt_choice_as_opt_read_id_3ff203e
          * (Token.t (* "=" *) * expression) option
        )
      | `EQ_exp of (Token.t (* "=" *) * expression)
    ]
)

and method_declaration = (
    modifiers option
  * Token.t (* "function" *)
  * method_header
  * block
  * semicolon
)

and method_declarator = (
    identifier (*tok*)
  * type_parameters option
  * fnparameters
)

and method_defination = (
    modifiers option
  * Token.t (* "function" *)
  * method_header
  * semicolon
)

and method_header = (
    method_declarator
  * (Token.t (* ":" *) * unannotated_type) option
)

and modifiers =
  [
      `Anno of annotation
    | `Priv of Token.t (* "private" *)
    | `Inte of Token.t (* "internal" *)
    | `Prot of Token.t (* "protected" *)
    | `Public of Token.t (* "public" *)
    | `Static of Token.t (* "static" *)
    | `Abst of Token.t (* "abstract" *)
    | `Over of Token.t (* "override" *)
    | `Final of Token.t (* "final" *)
    | `Tran of Token.t (* "transient" *)
  ]
    list (* one or more *)

and object_initializer = (
    Token.t (* ":" *) * anon_choice_id_fb82200 * Token.t (* "=" *)
  * variable_initializer
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and pattern = [ `Type_pat of type_pattern | `Record_pat of record_pattern ]

and permits = (Token.t (* "permits" *) * type_list)

and primary_expression = [
    `Lit of literal
  | `Class_lit of (
        unannotated_type * Token.t (* "." *) * Token.t (* "class" *)
    )
  | `This of Token.t (* "this" *)
  | `Id of identifier (*tok*)
  | `Paren_exp of parenthesized_expression
  | `Obj_crea_exp of (
        Token.t (* "new" *)
      * [
            `Rep_anno_type_args_rep_anno of (
                annotation list (* zero or more *)
              * type_arguments
              * annotation list (* zero or more *)
            )
          | `Rep_anno of annotation list (* zero or more *)
        ]
      * simple_type
      * argument_list
      * (
            Token.t (* "{" *)
          * [
                `Opt_obj_init_rep_COMMA_obj_init of
                  (
                      object_initializer
                    * (Token.t (* "," *) * object_initializer)
                        list (* zero or more *)
                  )
                    option
              | `Opt_meth_decl_rep_COMMA_meth_decl of
                  (
                      method_declaration
                    * (Token.t (* "," *) * method_declaration)
                        list (* zero or more *)
                  )
                    option
            ]
          * Token.t (* "}" *)
        )
          option
    )
  | `Field_access of field_access
  | `Array_access of array_access
  | `Meth_invo of (
        [
            `Id of identifier (*tok*)
          | `Choice_choice_exp_DOT_id of (
                [
                    `Choice_exp of variable_initializer
                  | `Super of Token.t (* "super" *)
                ]
              * Token.t (* "." *)
              * identifier (*tok*)
            )
        ]
      * type_arguments option
      * argument_list
    )
  | `Meth_ref of (
        [
            `Type of type_
          | `Prim_exp of primary_expression
          | `Super of Token.t (* "super" *)
        ]
      * Token.t (* "::" *)
      * type_arguments option
      * [ `New of Token.t (* "new" *) | `Id of identifier (*tok*) ]
    )
  | `Array_crea_exp of (
        Token.t (* "new" *)
      * annotation list (* zero or more *)
      * simple_type
      * [
            `Rep1_dimens_expr_opt_dimens of (
                dimensions_expr list (* one or more *)
              * dimensions option
            )
          | `Dimens_array_init of (dimensions * array_initializer)
        ]
    )
  | `Temp_exp of (primary_expression * Token.t (* "." *) * string_literal)
]

and range_expression = (expression * tok_choice_dotdot * expression)

and record_pattern = (
    [ `Id of identifier (*tok*) | `Gene_type of generic_type ]
  * record_pattern_body
)

and record_pattern_body = (
    Token.t (* "(" *)
  * (
        anon_choice_record_pat_comp_a91ed66
      * (Token.t (* "," *) * anon_choice_record_pat_comp_a91ed66)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and record_pattern_component = [
    `Unde_pat of Token.t (* "_" *)
  | `Unan_type_id of type_pattern
]

and resource = [
    `Opt_modifs_unan_type_var_decl_id_EQ_exp of (
        modifiers option
      * unannotated_type
      * variable_declarator_id
      * Token.t (* "=" *)
      * expression
    )
  | `Id of identifier (*tok*)
  | `Field_access of field_access
]

and resource_specification = (
    Token.t (* "(" *)
  * resource
  * (Token.t (* ";" *) * resource) list (* zero or more *)
  * Token.t (* ";" *) option
  * Token.t (* ")" *)
)

and scoped_type_identifier = (
    [
        `Id of identifier (*tok*)
      | `Scoped_type_id of scoped_type_identifier
      | `Gene_type of generic_type
    ]
  * Token.t (* "." *)
  * annotation list (* zero or more *)
  * identifier (*tok*)
)

and simple_type = [
    `Void_type of Token.t (* "void" *)
  | `Inte_type of integral_type
  | `Floa_point_type of floating_point_type
  | `Bool_type of Token.t (* "boolean" *)
  | `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier
  | `Gene_type of generic_type
  | `Blk_lit_type of (
        Token.t (* "block" *) * fnparameters * Token.t (* ":" *)
      * unannotated_type
    )
]

and statement = [
    `Decl of declaration
  | `Exp_stmt of expression_statement
  | `Labe_stmt of (identifier (*tok*) * Token.t (* ":" *) * statement)
  | `If_stmt of (
        Token.t (* "if" *)
      * parenthesized_expression
      * statement
      * (Token.t (* "else" *) * statement) option
    )
  | `While_stmt of (
        Token.t (* "while" *) * parenthesized_expression * statement
    )
  | `For_stmt of (
        anon_choice_fore_b3b5f65
      * Token.t (* "(" *)
      * Token.t (* "var" *) option
      * identifier (*tok*)
      * Token.t (* "in" *)
      * expression
      * indexrest option
      * Token.t (* ")" *)
      * statement
      * semicolon
    )
  | `Enha_for_stmt of (
        anon_choice_fore_b3b5f65
      * Token.t (* "(" *)
      * Token.t (* "var" *) option
      * identifier (*tok*)
      * Token.t (* "in" *)
      * range_expression
      * Token.t (* ")" *)
      * statement
      * semicolon
    )
  | `Blk of block
  | `SEMI of Token.t (* ";" *)
  | `Assert_stmt of assert_statement
  | `Do_stmt of (
        Token.t (* "do" *) * statement * Token.t (* "while" *)
      * parenthesized_expression * semicolon
    )
  | `Brk_stmt of (
        Token.t (* "break" *)
      * identifier (*tok*) option
      * semicolon
    )
  | `Cont_stmt of (
        Token.t (* "continue" *)
      * identifier (*tok*) option
      * semicolon
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * variable_initializer option
      * semicolon
    )
  | `Yield_stmt of (Token.t (* "yield" *) * expression * Token.t (* ";" *))
  | `Switch_exp of switch_expression
  | `Sync_stmt of (
        Token.t (* "synchronized" *) * parenthesized_expression * block
    )
  | `Local_var_decl of (
        modifiers option
      * Token.t (* "var" *)
      * variable_declarator
      * semicolon
    )
  | `Blk_lit_var_decl of (
        modifiers option
      * Token.t (* "var" *)
      * block_literal_identifier
      * semicolon
    )
  | `Throw_stmt of throw_statement
  | `Try_stmt of (
        Token.t (* "try" *)
      * block
      * [
            `Rep1_catch_clause of catch_clause list (* one or more *)
          | `Rep_catch_clause_fina_clause of (
                catch_clause list (* zero or more *)
              * finally_clause
            )
        ]
    )
  | `Try_with_resous_stmt of (
        Token.t (* "try" *)
      * resource_specification
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
  | `Eval_stmt of (
        Token.t (* "eval" *)
      * Token.t (* "(" *)
      * [
            `Bin_exp of binary_expression
          | `Un_exp of unary_expression
          | `Tern_exp of ternary_expression
        ]
      * Token.t (* ")" *)
    )
  | `Using_stmt of (
        Token.t (* "using" *)
      * Token.t (* "(" *)
      * [
            `Loca_rep_COMMA_loca of (
                localvarstatement
              * (Token.t (* "," *) * localvarstatement)
                  list (* zero or more *)
            )
          | `Exp of expression
        ]
      * Token.t (* ")" *)
      * block
      * finally_clause option
    )
  | `Super_stmt of (Token.t (* "super" *) * argument_list)
]

and string_interpolation = (
    Token.t (* "\\{" *) * expression * Token.t (* "}" *)
)

and string_literal = [
    `Str_lit_ of (
        Token.t (* "\"" *)
      * [
            `Str_frag of string_fragment (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
          | `Str_interp of string_interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Mult_str_lit of (
        Token.t (* "\"\"\"" *)
      * [
            `Mult_str_frag of multiline_string_fragment
          | `Esc_seq_ of escape_sequence_
          | `Str_interp of string_interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"\"\"" *)
    )
]

and super_interfaces = (Token.t (* "implements" *) * type_list)

and superclass = (Token.t (* "extends" *) * type_)

and switch_block = (
    Token.t (* "{" *)
  * [
        `Rep_switch_blk_stmt_group of
          switch_block_statement_group list (* zero or more *)
      | `Rep_switch_rule of switch_rule list (* zero or more *)
    ]
  * Token.t (* "}" *)
)

and switch_block_statement_group = (
    (switch_label * Token.t (* ":" *)) list (* one or more *)
  * statement list (* zero or more *)
)

and switch_expression = (
    Token.t (* "switch" *) * parenthesized_expression * switch_block
)

and switch_label = [
    `Case_choice_pat_opt_guard of (
        Token.t (* "case" *)
      * [
            `Pat of pattern
          | `Exp_rep_COMMA_exp of (
                expression
              * (Token.t (* "," *) * expression) list (* zero or more *)
            )
        ]
      * guard option
    )
  | `Defa of Token.t (* "default" *)
]

and switch_rule = (
    switch_label
  * Token.t (* "->" *)
  * [
        `Exp_stmt of expression_statement
      | `Throw_stmt of throw_statement
      | `Blk of block
    ]
)

and ternary_expression = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

and throw_statement = (Token.t (* "throw" *) * expression * semicolon)

and type_ = [
    `Unan_type of unannotated_type
  | `Anno_type of (annotation list (* one or more *) * unannotated_type)
]

and type_arguments = (
    Token.t (* "<" *)
  * (
        anon_choice_type_205a2ac
      * (Token.t (* "," *) * anon_choice_type_205a2ac)
          list (* zero or more *)
    )
      option
  * Token.t (* ">" *)
)

and type_bound = (
    Token.t (* "extends" *)
  * type_
  * (Token.t (* "&" *) * type_) list (* zero or more *)
)

and type_list = (type_ * (Token.t (* "," *) * type_) list (* zero or more *))

and type_parameter = (identifier (*tok*) * type_bound option)

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_pattern = (unannotated_type * identifier (*tok*))

and unannotated_type = [
    `Choice_void_type of simple_type
  | `Array_type of (unannotated_type * dimensions)
]

and unary_expression = [
    `PLUS_exp of (Token.t (* "+" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
  | `Not_exp of (Token.t (* "not" *) * expression)
  | `Typeof_exp of (Token.t (* "typeof" *) * expression)
  | `Stat_exp of (Token.t (* "statictypeof" *) * expression)
  | `Post_update_exp of (
        expression
      * [
            `Tok_plusps of tok_plusplus (*tok*)
          | `Tok_dash of tok_dashdash (*tok*)
        ]
    )
]

and unqualified_object_creation_expression = (
    Token.t (* "new" *)
  * [
        `Rep_anno_type_args_rep_anno of (
            annotation list (* zero or more *)
          * type_arguments
          * annotation list (* zero or more *)
        )
      | `Rep_anno of annotation list (* zero or more *)
    ]
  * simple_type
  * argument_list
  * (
        Token.t (* "{" *)
      * [
            `Opt_obj_init_rep_COMMA_obj_init of
              (
                  object_initializer
                * (Token.t (* "," *) * object_initializer)
                    list (* zero or more *)
              )
                option
          | `Opt_meth_decl_rep_COMMA_meth_decl of
              (
                  method_declaration
                * (Token.t (* "," *) * method_declaration)
                    list (* zero or more *)
              )
                option
        ]
      * Token.t (* "}" *)
    )
      option
)

and update_expression = [
    `Exp_PLUSPLUS of (expression * Token.t (* "++" *))
  | `Exp_DASHDASH of (expression * Token.t (* "--" *))
]

and variable_declarator = (
    anon_choice_id_fb82200
  * [
        `COLON_unan_type_opt_choice_as_opt_read_id_opt_EQ_choice_exp of (
            Token.t (* ":" *)
          * unannotated_type
          * anon_opt_choice_as_opt_read_id_3ff203e
          * (Token.t (* "=" *) * variable_initializer) option
        )
      | `EQ_choice_exp of (Token.t (* "=" *) * variable_initializer)
    ]
)

and variable_declarator_id = (anon_choice_id_fb82200 * dimensions option)

and variable_initializer = [
    `Exp of expression
  | `Array_init of array_initializer
  | `Map_init of (
        Token.t (* "{" *)
      * (
            variable_initializer
          * Token.t (* "->" *)
          * variable_initializer
          * (
                Token.t (* "," *) * variable_initializer * Token.t (* "->" *)
              * variable_initializer
            )
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
]

and wildcard_bounds = [
    `Extends_type of superclass
  | `Super_type of (Token.t (* "super" *) * type_)
]

type module_directive = [
    `Requis_module_dire of (
        Token.t (* "requires" *)
      * requires_modifier list (* zero or more *)
      * name
      * Token.t (* ";" *)
    )
  | `Exports_module_dire of (
        Token.t (* "exports" *)
      * name
      * anon_to_name_rep_COMMA_name_2956291 option
      * Token.t (* ";" *)
    )
  | `Opens_module_dire of (
        Token.t (* "opens" *)
      * name
      * anon_to_name_rep_COMMA_name_2956291 option
      * Token.t (* ";" *)
    )
  | `Uses_module_dire of (Token.t (* "uses" *) * name * semicolon)
  | `Provis_module_dire of (
        Token.t (* "provides" *)
      * name
      * Token.t (* "with" *)
      * name
      * (Token.t (* "," *) * name) list (* zero or more *)
      * Token.t (* ";" *)
    )
]

type enhancement_body = (
    Token.t (* "{" *)
  * method_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

type toplevel_statement = [
    `Stmt of statement
  | `Meth_decl of method_declaration
  | `Enha_decl of (
        Token.t (* "enhancement" *)
      * identifier (*tok*)
      * type_parameters option
      * Token.t (* ":" *)
      * unannotated_type
      * enhancement_body
    )
]

type program = toplevel_statement list (* zero or more *)

type underscore_pattern (* inlined *) = Token.t (* "_" *)

type block_comment (* inlined *) = Token.t

type line_comment (* inlined *) = Token.t

type true_ (* inlined *) = Token.t (* "true" *)

type super (* inlined *) = Token.t (* "super" *)

type asterisk (* inlined *) = Token.t (* "*" *)

type false_ (* inlined *) = Token.t (* "false" *)

type this (* inlined *) = Token.t (* "this" *)

type void_type (* inlined *) = Token.t (* "void" *)

type null_literal (* inlined *) = Token.t (* "null" *)

type boolean_type (* inlined *) = Token.t (* "boolean" *)

type scoped_identifier (* inlined *) = (
    name * Token.t (* "." *) * identifier (*tok*)
)

type inferred_parameters (* inlined *) = (
    Token.t (* "(" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* ")" *)
)

type delegate_declaration (* inlined *) = (
    Token.t (* "delegate" *) * identifier (*tok*)
  * Token.t (* "represents" *) * identifier (*tok*)
)

type requires_module_directive (* inlined *) = (
    Token.t (* "requires" *)
  * requires_modifier list (* zero or more *)
  * name
  * Token.t (* ";" *)
)

type provides_module_directive (* inlined *) = (
    Token.t (* "provides" *)
  * name
  * Token.t (* "with" *)
  * name
  * (Token.t (* "," *) * name) list (* zero or more *)
  * Token.t (* ";" *)
)

type marker_annotation (* inlined *) = (Token.t (* "@" *) * name)

type classpath_declaration (* inlined *) = (
    Token.t (* "classpath" *) * Token.t (* "\"" *) * name
  * Token.t (* "\"" *) * semicolon
)

type uses_declaration (* inlined *) = (
    Token.t (* "uses" *)
  * Token.t (* "static" *) option
  * name
  * (Token.t (* "." *) * Token.t (* "*" *)) option
  * semicolon
)

type uses_module_directive (* inlined *) = (
    Token.t (* "uses" *) * name * semicolon
)

type break_statement (* inlined *) = (
    Token.t (* "break" *)
  * identifier (*tok*) option
  * semicolon
)

type continue_statement (* inlined *) = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
  * semicolon
)

type opens_module_directive (* inlined *) = (
    Token.t (* "opens" *)
  * name
  * anon_to_name_rep_COMMA_name_2956291 option
  * Token.t (* ";" *)
)

type exports_module_directive (* inlined *) = (
    Token.t (* "exports" *)
  * name
  * anon_to_name_rep_COMMA_name_2956291 option
  * Token.t (* ";" *)
)

type annotated_type (* inlined *) = (
    annotation list (* one or more *)
  * unannotated_type
)

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * annotation list (* zero or more *)
  * simple_type
  * [
        `Rep1_dimens_expr_opt_dimens of (
            dimensions_expr list (* one or more *)
          * dimensions option
        )
      | `Dimens_array_init of (dimensions * array_initializer)
    ]
)

type array_type (* inlined *) = (unannotated_type * dimensions)

type assignment_expression (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Field_access of field_access
      | `Array_access of array_access
    ]
  * [
        `EQ of Token.t (* "=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `AMPAMPEQ of Token.t (* "&&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `BARBAREQ of Token.t (* "||=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
    ]
  * variable_initializer
)

type block_literal_type (* inlined *) = (
    Token.t (* "block" *) * fnparameters * Token.t (* ":" *)
  * unannotated_type
)

type block_literal_variable_declaration (* inlined *) = (
    modifiers option
  * Token.t (* "var" *)
  * block_literal_identifier
  * semicolon
)

type class_literal (* inlined *) = (
    unannotated_type * Token.t (* "." *) * Token.t (* "class" *)
)

type constructor_declaration (* inlined *) = (
    Token.t (* "construct" *) * formal_parameters * constructor_body
)

type do_statement (* inlined *) = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * parenthesized_expression * semicolon
)

type element_value_array_initializer (* inlined *) = (
    Token.t (* "{" *)
  * (
        element_value
      * (Token.t (* "," *) * element_value) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type enhanced_for_statement (* inlined *) = (
    anon_choice_fore_b3b5f65
  * Token.t (* "(" *)
  * Token.t (* "var" *) option
  * identifier (*tok*)
  * Token.t (* "in" *)
  * range_expression
  * Token.t (* ")" *)
  * statement
  * semicolon
)

type eval_statement (* inlined *) = (
    Token.t (* "eval" *)
  * Token.t (* "(" *)
  * [
        `Bin_exp of binary_expression
      | `Un_exp of unary_expression
      | `Tern_exp of ternary_expression
    ]
  * Token.t (* ")" *)
)

type field_declaration (* inlined *) = (
    modifiers option
  * Token.t (* "var" *)
  * variable_declarator
  * semicolon
)

type for_statement (* inlined *) = (
    anon_choice_fore_b3b5f65
  * Token.t (* "(" *)
  * Token.t (* "var" *) option
  * identifier (*tok*)
  * Token.t (* "in" *)
  * expression
  * indexrest option
  * Token.t (* ")" *)
  * statement
  * semicolon
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * parenthesized_expression
  * statement
  * (Token.t (* "else" *) * statement) option
)

type labeled_statement (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * statement
)

type local_variable_declaration (* inlined *) = (
    modifiers option
  * Token.t (* "var" *)
  * variable_declarator
  * semicolon
)

type map_initializer (* inlined *) = (
    Token.t (* "{" *)
  * (
        variable_initializer
      * Token.t (* "->" *)
      * variable_initializer
      * (
            Token.t (* "," *) * variable_initializer * Token.t (* "->" *)
          * variable_initializer
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type method_invocation (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Choice_choice_exp_DOT_id of (
            [
                `Choice_exp of variable_initializer
              | `Super of Token.t (* "super" *)
            ]
          * Token.t (* "." *)
          * identifier (*tok*)
        )
    ]
  * type_arguments option
  * argument_list
)

type method_reference (* inlined *) = (
    [
        `Type of type_
      | `Prim_exp of primary_expression
      | `Super of Token.t (* "super" *)
    ]
  * Token.t (* "::" *)
  * type_arguments option
  * [ `New of Token.t (* "new" *) | `Id of identifier (*tok*) ]
)

type multiline_string_literal (* inlined *) = (
    Token.t (* "\"\"\"" *)
  * [
        `Mult_str_frag of multiline_string_fragment
      | `Esc_seq_ of escape_sequence_
      | `Str_interp of string_interpolation
    ]
      list (* zero or more *)
  * Token.t (* "\"\"\"" *)
)

type object_creation_expression (* inlined *) =
  unqualified_object_creation_expression

type package_declaration (* inlined *) = (
    annotation list (* zero or more *)
  * Token.t (* "package" *)
  * name
  * semicolon
)

type postfix_update_expression (* inlined *) = (
    expression
  * [
        `Tok_plusps of tok_plusplus (*tok*)
      | `Tok_dash of tok_dashdash (*tok*)
    ]
)

type property_declaration (* inlined *) = (
    modifiers option
  * Token.t (* "property" *)
  * [ `Get of Token.t (* "get" *) | `Set of Token.t (* "set" *) ]
  * identifier (*tok*)
  * fnparameters
  * (Token.t (* ":" *) * unannotated_type) option
  * block
)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * variable_initializer option
  * semicolon
)

type static_initializer (* inlined *) = (Token.t (* "static" *) * block)

type string_literal_ (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Str_frag of string_fragment (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
      | `Str_interp of string_interpolation
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)

type super_statement (* inlined *) = (Token.t (* "super" *) * argument_list)

type synchronized_statement (* inlined *) = (
    Token.t (* "synchronized" *) * parenthesized_expression * block
)

type template_expression (* inlined *) = (
    primary_expression * Token.t (* "." *) * string_literal
)

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * [
        `Rep1_catch_clause of catch_clause list (* one or more *)
      | `Rep_catch_clause_fina_clause of (
            catch_clause list (* zero or more *)
          * finally_clause
        )
    ]
)

type try_with_resources_statement (* inlined *) = (
    Token.t (* "try" *)
  * resource_specification
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)

type type_literal_expression (* inlined *) = (
    [
        `Typeof of Token.t (* "typeof" *)
      | `Stat of Token.t (* "statictypeof" *)
    ]
  * parenthesized_expression
)

type typeis_expression (* inlined *) = (
    expression
  * Token.t (* "typeis" *)
  * Token.t (* "final" *) option
  * [
        `Type_opt_id of (type_ * identifier (*tok*) option)
      | `Record_pat of record_pattern
    ]
)

type using_statement (* inlined *) = (
    Token.t (* "using" *)
  * Token.t (* "(" *)
  * [
        `Loca_rep_COMMA_loca of (
            localvarstatement
          * (Token.t (* "," *) * localvarstatement) list (* zero or more *)
        )
      | `Exp of expression
    ]
  * Token.t (* ")" *)
  * block
  * finally_clause option
)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * parenthesized_expression * statement
)

type wildcard (* inlined *) = (
    annotation list (* zero or more *)
  * Token.t (* "?" *)
  * wildcard_bounds option
)

type yield_statement (* inlined *) = (
    Token.t (* "yield" *) * expression * Token.t (* ";" *)
)

type explicit_constructor_invocation (* inlined *) = (
    [
        `Opt_type_args_choice_this of (
            type_arguments option
          * [
                `This of Token.t (* "this" *)
              | `Super of Token.t (* "super" *)
            ]
        )
      | `Choice_prim_exp_DOT_opt_type_args_super of (
            [ `Prim_exp of primary_expression ]
          * Token.t (* "." *)
          * type_arguments option
          * Token.t (* "super" *)
        )
    ]
  * argument_list
  * Token.t (* ";" *)
)

type throws (* inlined *) = (
    Token.t (* "throws" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)

type receiver_parameter (* inlined *) = (
    annotation list (* zero or more *)
  * unannotated_type
  * (identifier (*tok*) * Token.t (* "." *)) list (* zero or more *)
  * Token.t (* "this" *)
)

type compact_constructor_declaration (* inlined *) = (
    modifiers option
  * identifier (*tok*)
  * block
)

type catch_type (* inlined *) = (
    unannotated_type
  * (Token.t (* "|" *) * unannotated_type) list (* zero or more *)
)

type spread_parameter (* inlined *) = (
    modifiers option
  * unannotated_type
  * Token.t (* "..." *)
  * annotation list (* zero or more *)
  * variable_declarator
)

type fnparameterdeclarationlist (* inlined *) = (
    fnparameterdeclaration
  * (Token.t (* "," *) * fnparameterdeclaration) list (* zero or more *)
)

type module_body (* inlined *) = (
    Token.t (* "{" *)
  * module_directive list (* zero or more *)
  * Token.t (* "}" *)
)

type enhancement_declaration (* inlined *) = (
    Token.t (* "enhancement" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* ":" *)
  * unannotated_type
  * enhancement_body
)

type extra = [
    `Line_comment of Loc.t * line_comment
  | `Block_comment of Loc.t * block_comment
]

type extras = extra list
