(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_gosu"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "line_comment";
  "block_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "block_comment", None;
  "tok_dashdash", None;
  "decimal_floating_point_literal", None;
  "decimal_integer_literal", None;
  "asterisk", None;
  "false", None;
  "void_type", None;
  "binary_integer_literal", None;
  "floating_point_type",
  Some (
    Alt [|
      Token (Literal "float");
      Token (Literal "double");
    |];
  );
  "line_comment", None;
  "string_fragment", None;
  "hex_floating_point_literal", None;
  "character_literal", None;
  "tok_plusplus", None;
  "escape_sequence", None;
  "this", None;
  "hex_integer_literal", None;
  "tok_choice_dotdot", None;
  "super", None;
  "integral_type",
  Some (
    Alt [|
      Token (Literal "byte");
      Token (Literal "short");
      Token (Literal "int");
      Token (Literal "long");
      Token (Literal "char");
    |];
  );
  "identifier", None;
  "true", None;
  "pat_3a2a380", None;
  "octal_integer_literal", None;
  "boolean_type", None;
  "infinity_literal", None;
  "nan_literal", None;
  "pat_22cdef7", None;
  "underscore_pattern", None;
  "imm_tok_bslash_pat_e8ee8e5", None;
  "null_literal", None;
  "automatic_semicolon", None;
  "indexvar",
  Some (
    Seq [
      Token (Literal "index");
      Token (Name "identifier");
    ];
  );
  "delegate_declaration",
  Some (
    Seq [
      Token (Literal "delegate");
      Token (Name "identifier");
      Token (Literal "represents");
      Token (Name "identifier");
    ];
  );
  "scoped_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "catch_formal_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "iteratorvar",
  Some (
    Seq [
      Token (Literal "iterator");
      Token (Name "identifier");
    ];
  );
  "multiline_string_fragment",
  Some (
    Alt [|
      Token (Name "pat_3a2a380");
      Token (Name "pat_22cdef7");
    |];
  );
  "escape_sequence_",
  Some (
    Alt [|
      Token (Name "imm_tok_bslash_pat_e8ee8e5");
      Token (Name "escape_sequence");
    |];
  );
  "semicolon",
  Some (
    Alt [|
      Token (Name "automatic_semicolon");
      Token (Literal ";");
    |];
  );
  "marker_annotation",
  Some (
    Seq [
      Token (Literal "@");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
    ];
  );
  "indexrest",
  Some (
    Alt [|
      Seq [
        Token (Name "indexvar");
        Opt (
          Token (Name "iteratorvar");
        );
      ];
      Seq [
        Token (Name "iteratorvar");
        Opt (
          Token (Name "indexvar");
        );
      ];
    |];
  );
  "classpath_declaration",
  Some (
    Seq [
      Token (Literal "classpath");
      Token (Literal "\"");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Literal "\"");
      Token (Name "semicolon");
    ];
  );
  "continue_statement",
  Some (
    Seq [
      Token (Literal "continue");
      Opt (
        Token (Name "identifier");
      );
      Token (Name "semicolon");
    ];
  );
  "uses_declaration",
  Some (
    Seq [
      Token (Literal "uses");
      Opt (
        Token (Literal "static");
      );
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Opt (
        Seq [
          Token (Literal ".");
          Token (Name "asterisk");
        ];
      );
      Token (Name "semicolon");
    ];
  );
  "break_statement",
  Some (
    Seq [
      Token (Literal "break");
      Opt (
        Token (Name "identifier");
      );
      Token (Name "semicolon");
    ];
  );
  "annotated_type",
  Some (
    Seq [
      Repeat1 (
        Token (Name "annotation");
      );
      Token (Name "unannotated_type");
    ];
  );
  "annotation",
  Some (
    Alt [|
      Token (Name "marker_annotation");
      Token (Name "annotation_");
    |];
  );
  "annotation_",
  Some (
    Seq [
      Token (Literal "@");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Name "annotation_argument_list");
    ];
  );
  "annotation_argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "element_value");
        Opt (
          Seq [
            Token (Name "element_value_pair");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "element_value_pair");
              ];
            );
          ];
        );
      |];
      Token (Literal ")");
    ];
  );
  "annotation_type_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "annotation_type_element_declaration");
          Token (Name "constant_declaration");
          Token (Name "class_declaration");
          Token (Name "interface_declaration");
          Token (Name "enum_declaration");
          Token (Name "annotation_type_declaration");
          Token (Literal ";");
        |];
      );
      Token (Literal "}");
    ];
  );
  "annotation_type_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "@interface");
      Token (Name "identifier");
      Token (Name "annotation_type_body");
    ];
  );
  "annotation_type_element_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "unannotated_type");
      Token (Name "identifier");
      Token (Literal "(");
      Token (Literal ")");
      Opt (
        Token (Name "dimensions");
      );
      Opt (
        Token (Name "default_value");
      );
      Token (Literal ";");
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
            Token (Name "map_initializer");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
                Token (Name "map_initializer");
              |];
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "array_access",
  Some (
    Seq [
      Token (Name "primary_expression");
      Opt (
        Token (Literal "?");
      );
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "array_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Repeat (
        Token (Name "annotation");
      );
      Alt [|
        Token (Name "void_type");
        Token (Name "integral_type");
        Token (Name "floating_point_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
        Token (Name "block_literal_type");
      |];
      Alt [|
        Seq [
          Repeat1 (
            Token (Name "dimensions_expr");
          );
          Opt (
            Token (Name "dimensions");
          );
        ];
        Seq [
          Token (Name "dimensions");
          Token (Name "array_initializer");
        ];
      |];
    ];
  );
  "array_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
            Token (Name "map_initializer");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
                Token (Name "map_initializer");
              |];
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "array_type",
  Some (
    Seq [
      Token (Name "unannotated_type");
      Token (Name "dimensions");
    ];
  );
  "assert_statement",
  Some (
    Alt [|
      Seq [
        Token (Literal "assert");
        Token (Name "expression");
        Token (Name "semicolon");
      ];
      Seq [
        Token (Literal "assert");
        Token (Name "expression");
        Token (Literal ":");
        Token (Name "expression");
        Token (Name "semicolon");
      ];
    |];
  );
  "assignment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "field_access");
        Token (Name "array_access");
      |];
      Alt [|
        Token (Literal "=");
        Token (Literal "+=");
        Token (Literal "-=");
        Token (Literal "*=");
        Token (Literal "/=");
        Token (Literal "&=");
        Token (Literal "&&=");
        Token (Literal "|=");
        Token (Literal "||=");
        Token (Literal "^=");
        Token (Literal "%=");
        Token (Literal "<<=");
        Token (Literal ">>=");
        Token (Literal ">>>=");
      |];
      Alt [|
        Token (Name "expression");
        Token (Name "array_initializer");
        Token (Name "map_initializer");
      |];
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal ">");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "===");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "and");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "or");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "?+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "?-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "?*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "?/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "?%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>>");
        Token (Name "expression");
      ];
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "block_definition_expression",
  Some (
    Seq [
      Token (Literal "\\");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
        ];
      );
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
          Opt (
            Seq [
              Token (Literal ":");
              Token (Name "unannotated_type");
            ];
          );
        ];
      );
      Token (Literal "->");
      Alt [|
        Token (Name "expression");
        Token (Name "block");
      |];
    ];
  );
  "block_literal_identifier",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "fnparameters");
      Token (Literal ":");
      Token (Name "unannotated_type");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "block_literal_type",
  Some (
    Seq [
      Token (Literal "block");
      Token (Name "fnparameters");
      Token (Literal ":");
      Token (Name "unannotated_type");
    ];
  );
  "block_literal_variable_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "var");
      Token (Name "block_literal_identifier");
      Token (Name "semicolon");
    ];
  );
  "cast_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Name "type");
        Token (Literal ")");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "as");
          Token (Literal "typeas");
        |];
        Token (Name "type");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "type");
        Repeat (
          Seq [
            Token (Literal "&");
            Token (Name "type");
          ];
        );
        Token (Literal ")");
        Alt [|
          Token (Name "primary_expression");
          Token (Name "block_definition_expression");
        |];
      ];
    |];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Literal "catch");
      Token (Literal "(");
      Token (Name "catch_formal_parameter");
      Token (Literal ")");
      Token (Name "block");
    ];
  );
  "class_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "field_declaration");
          Token (Name "property_declaration");
          Token (Name "method_declaration");
          Token (Name "class_declaration");
          Token (Name "interface_declaration");
          Token (Name "enum_declaration");
          Token (Name "static_initializer");
          Token (Name "constructor_declaration");
          Token (Name "delegate_declaration");
          Token (Literal ";");
        |];
      );
      Token (Literal "}");
    ];
  );
  "class_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "class");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "superclass");
      );
      Opt (
        Token (Name "super_interfaces");
      );
      Opt (
        Token (Name "permits");
      );
      Token (Name "class_body");
    ];
  );
  "class_literal",
  Some (
    Seq [
      Token (Name "unannotated_type");
      Token (Literal ".");
      Token (Literal "class");
    ];
  );
  "constant_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "var");
      Token (Name "variable_declarator");
      Token (Name "semicolon");
    ];
  );
  "constructor_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "constructor_declaration",
  Some (
    Seq [
      Token (Literal "construct");
      Token (Name "formal_parameters");
      Token (Name "constructor_body");
    ];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "package_declaration");
      Token (Name "classpath_declaration");
      Token (Name "uses_declaration");
      Token (Name "class_declaration");
      Token (Name "interface_declaration");
      Token (Name "annotation_type_declaration");
      Token (Name "enum_declaration");
    |];
  );
  "default_value",
  Some (
    Seq [
      Token (Literal "default");
      Token (Name "element_value");
    ];
  );
  "dimensions",
  Some (
    Repeat1 (
      Seq [
        Repeat (
          Token (Name "annotation");
        );
        Token (Literal "[");
        Token (Literal "]");
      ];
    );
  );
  "dimensions_expr",
  Some (
    Seq [
      Repeat (
        Token (Name "annotation");
      );
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "do_statement",
  Some (
    Seq [
      Token (Literal "do");
      Token (Name "statement");
      Token (Literal "while");
      Token (Name "parenthesized_expression");
      Token (Name "semicolon");
    ];
  );
  "element_value",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "element_value_array_initializer");
      Token (Name "annotation");
    |];
  );
  "element_value_array_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "element_value");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "element_value");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "element_value_pair",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "element_value");
    ];
  );
  "enhanced_for_statement",
  Some (
    Seq [
      Alt [|
        Token (Literal "foreach");
        Token (Literal "for");
      |];
      Token (Literal "(");
      Opt (
        Token (Literal "var");
      );
      Token (Name "identifier");
      Token (Literal "in");
      Token (Name "range_expression");
      Token (Literal ")");
      Token (Name "statement");
      Token (Name "semicolon");
    ];
  );
  "enum_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "enum_constant");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "enum_constant");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "enum_constant",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "identifier");
      Opt (
        Token (Name "argument_list");
      );
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "enum_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "enum");
      Token (Name "identifier");
      Token (Name "enum_body");
    ];
  );
  "eval_statement",
  Some (
    Seq [
      Token (Literal "eval");
      Token (Literal "(");
      Alt [|
        Token (Name "binary_expression");
        Token (Name "unary_expression");
        Token (Name "ternary_expression");
      |];
      Token (Literal ")");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "binary_expression");
      Token (Name "primary_expression");
      Token (Name "assignment_expression");
      Token (Name "typeis_expression");
      Token (Name "block_definition_expression");
      Token (Name "ternary_expression");
      Token (Name "update_expression");
      Token (Name "unary_expression");
      Token (Name "cast_expression");
      Token (Name "switch_expression");
      Token (Name "type_literal_expression");
    |];
  );
  "expression_statement",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "extends_interfaces",
  Some (
    Seq [
      Token (Literal "extends");
      Token (Name "type_list");
    ];
  );
  "field_access",
  Some (
    Seq [
      Alt [|
        Token (Name "primary_expression");
        Token (Name "super");
      |];
      Alt [|
        Token (Literal ".");
        Token (Literal "?.");
        Token (Literal "*.");
      |];
      Alt [|
        Token (Name "identifier");
        Token (Name "this");
      |];
    ];
  );
  "field_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "var");
      Token (Name "variable_declarator");
      Token (Name "semicolon");
    ];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Literal "finally");
      Token (Name "block");
    ];
  );
  "fnparameterdeclaration",
  Some (
    Seq [
      Opt (
        Repeat (
          Token (Name "annotation_");
        );
      );
      Opt (
        Token (Literal "final");
      );
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
        ];
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "fnparameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "fnparameterdeclaration");
            Token (Name "block_literal_identifier");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "fnparameterdeclaration");
                Token (Name "block_literal_identifier");
              |];
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "for_statement",
  Some (
    Seq [
      Alt [|
        Token (Literal "foreach");
        Token (Literal "for");
      |];
      Token (Literal "(");
      Opt (
        Token (Literal "var");
      );
      Token (Name "identifier");
      Token (Literal "in");
      Token (Name "expression");
      Opt (
        Token (Name "indexrest");
      );
      Token (Literal ")");
      Token (Name "statement");
      Token (Name "semicolon");
    ];
  );
  "formal_parameter",
  Some (
    Seq [
      Token (Name "variable_declarator_id");
      Alt [|
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
          Opt (
            Seq [
              Token (Literal "=");
              Token (Name "expression");
            ];
          );
        ];
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      |];
    ];
  );
  "formal_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "formal_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "formal_parameter");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "generic_type",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
      |];
      Token (Name "type_arguments");
    ];
  );
  "guard",
  Some (
    Seq [
      Token (Literal "when");
      Token (Name "expression");
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "parenthesized_expression");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "interface_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "constant_declaration");
          Token (Name "enum_declaration");
          Token (Name "method_defination");
          Token (Name "class_declaration");
          Token (Name "interface_declaration");
          Token (Name "annotation_type_declaration");
          Token (Literal ";");
        |];
      );
      Token (Literal "}");
    ];
  );
  "interface_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "interface");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "extends_interfaces");
      );
      Opt (
        Token (Name "permits");
      );
      Token (Name "interface_body");
    ];
  );
  "labeled_statement",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "statement");
    ];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "decimal_integer_literal");
      Token (Name "hex_integer_literal");
      Token (Name "octal_integer_literal");
      Token (Name "binary_integer_literal");
      Token (Name "decimal_floating_point_literal");
      Token (Name "hex_floating_point_literal");
      Token (Name "true");
      Token (Name "false");
      Token (Name "character_literal");
      Token (Name "string_literal");
      Token (Name "null_literal");
      Token (Name "infinity_literal");
      Token (Name "nan_literal");
    |];
  );
  "local_variable_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "var");
      Token (Name "variable_declarator");
      Token (Name "semicolon");
    ];
  );
  "localvarstatement",
  Some (
    Seq [
      Token (Literal "var");
      Alt [|
        Token (Name "identifier");
        Token (Name "underscore_pattern");
      |];
      Alt [|
        Seq [
          Token (Literal ":");
          Token (Name "type");
          Opt (
            Seq [
              Alt [|
                Token (Literal "as");
                Token (Literal "typeas");
              |];
              Opt (
                Token (Literal "readonly");
              );
              Token (Name "identifier");
            ];
          );
          Opt (
            Seq [
              Token (Literal "=");
              Token (Name "expression");
            ];
          );
        ];
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      |];
    ];
  );
  "map_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
            Token (Name "map_initializer");
          |];
          Token (Literal "->");
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
            Token (Name "map_initializer");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
                Token (Name "map_initializer");
              |];
              Token (Literal "->");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
                Token (Name "map_initializer");
              |];
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "method_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "function");
      Token (Name "method_header");
      Token (Name "block");
      Token (Name "semicolon");
    ];
  );
  "method_declarator",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "fnparameters");
    ];
  );
  "method_defination",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "function");
      Token (Name "method_header");
      Token (Name "semicolon");
    ];
  );
  "method_header",
  Some (
    Seq [
      Token (Name "method_declarator");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
        ];
      );
    ];
  );
  "method_invocation",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Seq [
          Alt [|
            Alt [|
              Token (Name "expression");
              Token (Name "array_initializer");
              Token (Name "map_initializer");
            |];
            Token (Name "super");
          |];
          Token (Literal ".");
          Token (Name "identifier");
        ];
      |];
      Opt (
        Token (Name "type_arguments");
      );
      Token (Name "argument_list");
    ];
  );
  "method_reference",
  Some (
    Seq [
      Alt [|
        Token (Name "type");
        Token (Name "primary_expression");
        Token (Name "super");
      |];
      Token (Literal "::");
      Opt (
        Token (Name "type_arguments");
      );
      Alt [|
        Token (Literal "new");
        Token (Name "identifier");
      |];
    ];
  );
  "modifiers",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "annotation");
        Token (Literal "private");
        Token (Literal "internal");
        Token (Literal "protected");
        Token (Literal "public");
        Token (Literal "static");
        Token (Literal "abstract");
        Token (Literal "override");
        Token (Literal "final");
        Token (Literal "transient");
      |];
    );
  );
  "multiline_string_literal",
  Some (
    Seq [
      Token (Literal "\"\"\"");
      Repeat (
        Alt [|
          Token (Name "multiline_string_fragment");
          Token (Name "escape_sequence_");
          Token (Name "string_interpolation");
        |];
      );
      Token (Literal "\"\"\"");
    ];
  );
  "object_creation_expression",
  Some (
    Token (Name "unqualified_object_creation_expression");
  );
  "object_initializer",
  Some (
    Seq [
      Token (Literal ":");
      Alt [|
        Token (Name "identifier");
        Token (Name "underscore_pattern");
      |];
      Token (Literal "=");
      Alt [|
        Token (Name "expression");
        Token (Name "array_initializer");
        Token (Name "map_initializer");
      |];
    ];
  );
  "package_declaration",
  Some (
    Seq [
      Repeat (
        Token (Name "annotation");
      );
      Token (Literal "package");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Name "semicolon");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "pattern",
  Some (
    Alt [|
      Token (Name "type_pattern");
      Token (Name "record_pattern");
    |];
  );
  "permits",
  Some (
    Seq [
      Token (Literal "permits");
      Token (Name "type_list");
    ];
  );
  "postfix_update_expression",
  Some (
    Seq [
      Token (Name "expression");
      Alt [|
        Token (Name "tok_plusplus");
        Token (Name "tok_dashdash");
      |];
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Token (Name "literal");
      Token (Name "class_literal");
      Token (Name "this");
      Token (Name "identifier");
      Token (Name "parenthesized_expression");
      Token (Name "object_creation_expression");
      Token (Name "field_access");
      Token (Name "array_access");
      Token (Name "method_invocation");
      Token (Name "method_reference");
      Token (Name "array_creation_expression");
      Token (Name "template_expression");
    |];
  );
  "property_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "property");
      Alt [|
        Token (Literal "get");
        Token (Literal "set");
      |];
      Token (Name "identifier");
      Token (Name "fnparameters");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
        ];
      );
      Token (Name "block");
    ];
  );
  "range_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "tok_choice_dotdot");
      Token (Name "expression");
    ];
  );
  "record_pattern",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "generic_type");
      |];
      Token (Name "record_pattern_body");
    ];
  );
  "record_pattern_body",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "record_pattern_component");
            Token (Name "record_pattern");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "record_pattern_component");
                Token (Name "record_pattern");
              |];
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "record_pattern_component",
  Some (
    Alt [|
      Token (Name "underscore_pattern");
      Seq [
        Token (Name "unannotated_type");
        Token (Name "identifier");
      ];
    |];
  );
  "resource",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Token (Name "unannotated_type");
        Token (Name "variable_declarator_id");
        Token (Literal "=");
        Token (Name "expression");
      ];
      Token (Name "identifier");
      Token (Name "field_access");
    |];
  );
  "resource_specification",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "resource");
      Repeat (
        Seq [
          Token (Literal ";");
          Token (Name "resource");
        ];
      );
      Opt (
        Token (Literal ";");
      );
      Token (Literal ")");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Alt [|
          Token (Name "expression");
          Token (Name "array_initializer");
          Token (Name "map_initializer");
        |];
      );
      Token (Name "semicolon");
    ];
  );
  "scoped_type_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Token (Literal ".");
      Repeat (
        Token (Name "annotation");
      );
      Token (Name "identifier");
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "declaration");
      Token (Name "expression_statement");
      Token (Name "labeled_statement");
      Token (Name "if_statement");
      Token (Name "while_statement");
      Token (Name "for_statement");
      Token (Name "enhanced_for_statement");
      Token (Name "block");
      Token (Literal ";");
      Token (Name "assert_statement");
      Token (Name "do_statement");
      Token (Name "break_statement");
      Token (Name "continue_statement");
      Token (Name "return_statement");
      Token (Name "yield_statement");
      Token (Name "switch_expression");
      Token (Name "synchronized_statement");
      Token (Name "local_variable_declaration");
      Token (Name "block_literal_variable_declaration");
      Token (Name "throw_statement");
      Token (Name "try_statement");
      Token (Name "try_with_resources_statement");
      Token (Name "eval_statement");
      Token (Name "using_statement");
      Token (Name "super_statement");
    |];
  );
  "static_initializer",
  Some (
    Seq [
      Token (Literal "static");
      Token (Name "block");
    ];
  );
  "string_interpolation",
  Some (
    Seq [
      Token (Literal "\\{");
      Token (Name "expression");
      Token (Literal "}");
    ];
  );
  "string_literal",
  Some (
    Alt [|
      Token (Name "string_literal_");
      Token (Name "multiline_string_literal");
    |];
  );
  "string_literal_",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Token (Name "string_fragment");
          Token (Name "escape_sequence");
          Token (Name "string_interpolation");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "super_interfaces",
  Some (
    Seq [
      Token (Literal "implements");
      Token (Name "type_list");
    ];
  );
  "super_statement",
  Some (
    Seq [
      Token (Name "super");
      Token (Name "argument_list");
    ];
  );
  "superclass",
  Some (
    Seq [
      Token (Literal "extends");
      Token (Name "type");
    ];
  );
  "switch_block",
  Some (
    Seq [
      Token (Literal "{");
      Alt [|
        Repeat (
          Token (Name "switch_block_statement_group");
        );
        Repeat (
          Token (Name "switch_rule");
        );
      |];
      Token (Literal "}");
    ];
  );
  "switch_block_statement_group",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "switch_label");
          Token (Literal ":");
        ];
      );
      Repeat (
        Token (Name "statement");
      );
    ];
  );
  "switch_expression",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Name "parenthesized_expression");
      Token (Name "switch_block");
    ];
  );
  "switch_label",
  Some (
    Alt [|
      Seq [
        Token (Literal "case");
        Alt [|
          Token (Name "pattern");
          Seq [
            Token (Name "expression");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expression");
              ];
            );
          ];
        |];
        Opt (
          Token (Name "guard");
        );
      ];
      Token (Literal "default");
    |];
  );
  "switch_rule",
  Some (
    Seq [
      Token (Name "switch_label");
      Token (Literal "->");
      Alt [|
        Token (Name "expression_statement");
        Token (Name "throw_statement");
        Token (Name "block");
      |];
    ];
  );
  "synchronized_statement",
  Some (
    Seq [
      Token (Literal "synchronized");
      Token (Name "parenthesized_expression");
      Token (Name "block");
    ];
  );
  "template_expression",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal ".");
      Token (Name "string_literal");
    ];
  );
  "ternary_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "throw_statement",
  Some (
    Seq [
      Token (Literal "throw");
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "try_statement",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "block");
      Alt [|
        Repeat1 (
          Token (Name "catch_clause");
        );
        Seq [
          Repeat (
            Token (Name "catch_clause");
          );
          Token (Name "finally_clause");
        ];
      |];
    ];
  );
  "try_with_resources_statement",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "resource_specification");
      Token (Name "block");
      Repeat (
        Token (Name "catch_clause");
      );
      Opt (
        Token (Name "finally_clause");
      );
    ];
  );
  "type",
  Some (
    Alt [|
      Token (Name "unannotated_type");
      Token (Name "annotated_type");
    |];
  );
  "type_arguments",
  Some (
    Seq [
      Token (Literal "<");
      Opt (
        Seq [
          Alt [|
            Token (Name "type");
            Token (Name "wildcard");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "type");
                Token (Name "wildcard");
              |];
            ];
          );
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_bound",
  Some (
    Seq [
      Token (Literal "extends");
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal "&");
          Token (Name "type");
        ];
      );
    ];
  );
  "type_list",
  Some (
    Seq [
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type");
        ];
      );
    ];
  );
  "type_literal_expression",
  Some (
    Seq [
      Alt [|
        Token (Literal "typeof");
        Token (Literal "statictypeof");
      |];
      Token (Name "parenthesized_expression");
    ];
  );
  "type_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "type_bound");
      );
    ];
  );
  "type_parameters",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_pattern",
  Some (
    Seq [
      Token (Name "unannotated_type");
      Token (Name "identifier");
    ];
  );
  "typeis_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "typeis");
      Opt (
        Token (Literal "final");
      );
      Alt [|
        Seq [
          Token (Name "type");
          Opt (
            Token (Name "identifier");
          );
        ];
        Token (Name "record_pattern");
      |];
    ];
  );
  "unannotated_type",
  Some (
    Alt [|
      Alt [|
        Token (Name "void_type");
        Token (Name "integral_type");
        Token (Name "floating_point_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
        Token (Name "block_literal_type");
      |];
      Token (Name "array_type");
    |];
  );
  "unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "not");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "typeof");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "statictypeof");
        Token (Name "expression");
      ];
      Token (Name "postfix_update_expression");
    |];
  );
  "unqualified_object_creation_expression",
  Some (
    Seq [
      Token (Literal "new");
      Alt [|
        Seq [
          Repeat (
            Token (Name "annotation");
          );
          Token (Name "type_arguments");
          Repeat (
            Token (Name "annotation");
          );
        ];
        Repeat (
          Token (Name "annotation");
        );
      |];
      Alt [|
        Token (Name "void_type");
        Token (Name "integral_type");
        Token (Name "floating_point_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
        Token (Name "block_literal_type");
      |];
      Token (Name "argument_list");
      Opt (
        Seq [
          Token (Literal "{");
          Alt [|
            Opt (
              Seq [
                Token (Name "object_initializer");
                Repeat (
                  Seq [
                    Token (Literal ",");
                    Token (Name "object_initializer");
                  ];
                );
              ];
            );
            Opt (
              Seq [
                Token (Name "method_declaration");
                Repeat (
                  Seq [
                    Token (Literal ",");
                    Token (Name "method_declaration");
                  ];
                );
              ];
            );
          |];
          Token (Literal "}");
        ];
      );
    ];
  );
  "update_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "++");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "--");
      ];
    |];
  );
  "using_statement",
  Some (
    Seq [
      Token (Literal "using");
      Token (Literal "(");
      Alt [|
        Seq [
          Token (Name "localvarstatement");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "localvarstatement");
            ];
          );
        ];
        Token (Name "expression");
      |];
      Token (Literal ")");
      Token (Name "block");
      Opt (
        Token (Name "finally_clause");
      );
    ];
  );
  "variable_declarator",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "underscore_pattern");
      |];
      Alt [|
        Seq [
          Token (Literal ":");
          Token (Name "unannotated_type");
          Opt (
            Seq [
              Alt [|
                Token (Literal "as");
                Token (Literal "typeas");
              |];
              Opt (
                Token (Literal "readonly");
              );
              Token (Name "identifier");
            ];
          );
          Opt (
            Seq [
              Token (Literal "=");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
                Token (Name "map_initializer");
              |];
            ];
          );
        ];
        Seq [
          Token (Literal "=");
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
            Token (Name "map_initializer");
          |];
        ];
      |];
    ];
  );
  "variable_declarator_id",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "underscore_pattern");
      |];
      Opt (
        Token (Name "dimensions");
      );
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Name "parenthesized_expression");
      Token (Name "statement");
    ];
  );
  "wildcard",
  Some (
    Seq [
      Repeat (
        Token (Name "annotation");
      );
      Token (Literal "?");
      Opt (
        Token (Name "wildcard_bounds");
      );
    ];
  );
  "wildcard_bounds",
  Some (
    Alt [|
      Seq [
        Token (Literal "extends");
        Token (Name "type");
      ];
      Seq [
        Token (Name "super");
        Token (Name "type");
      ];
    |];
  );
  "yield_statement",
  Some (
    Seq [
      Token (Literal "yield");
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "enhancement_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "method_declaration");
      );
      Token (Literal "}");
    ];
  );
  "enhancement_declaration",
  Some (
    Seq [
      Token (Literal "enhancement");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Literal ":");
      Token (Name "unannotated_type");
      Token (Name "enhancement_body");
    ];
  );
  "toplevel_statement",
  Some (
    Alt [|
      Token (Name "statement");
      Token (Name "method_declaration");
      Token (Name "enhancement_declaration");
    |];
  );
  "program",
  Some (
    Repeat (
      Token (Name "toplevel_statement");
    );
  );
]

let trans_block_comment ((kind, body) : mt) : CST.block_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_dashdash ((kind, body) : mt) : CST.tok_dashdash =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_floating_point_literal ((kind, body) : mt) : CST.decimal_floating_point_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_integer_literal ((kind, body) : mt) : CST.decimal_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_asterisk ((kind, body) : mt) : CST.asterisk =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_void_type ((kind, body) : mt) : CST.void_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_binary_integer_literal ((kind, body) : mt) : CST.binary_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_floating_point_type ((kind, body) : mt) : CST.floating_point_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Float (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Double (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_line_comment ((kind, body) : mt) : CST.line_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_fragment ((kind, body) : mt) : CST.string_fragment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_floating_point_literal ((kind, body) : mt) : CST.hex_floating_point_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_character_literal ((kind, body) : mt) : CST.character_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_plusplus ((kind, body) : mt) : CST.tok_plusplus =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_this ((kind, body) : mt) : CST.this =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_integer_literal ((kind, body) : mt) : CST.hex_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_choice_dotdot ((kind, body) : mt) : CST.tok_choice_dotdot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_super ((kind, body) : mt) : CST.super =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_integral_type ((kind, body) : mt) : CST.integral_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Byte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Short (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Int (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Long (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Char (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_3a2a380 ((kind, body) : mt) : CST.pat_3a2a380 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_octal_integer_literal ((kind, body) : mt) : CST.octal_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_boolean_type ((kind, body) : mt) : CST.boolean_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_infinity_literal ((kind, body) : mt) : CST.infinity_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nan_literal ((kind, body) : mt) : CST.nan_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_22cdef7 ((kind, body) : mt) : CST.pat_22cdef7 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_underscore_pattern ((kind, body) : mt) : CST.underscore_pattern =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_bslash_pat_e8ee8e5 ((kind, body) : mt) : CST.imm_tok_bslash_pat_e8ee8e5 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_automatic_semicolon ((kind, body) : mt) : CST.automatic_semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_indexvar ((kind, body) : mt) : CST.indexvar =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_delegate_declaration ((kind, body) : mt) : CST.delegate_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_scoped_identifier ((kind, body) : mt) : CST.scoped_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_catch_formal_parameter ((kind, body) : mt) : CST.catch_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_iteratorvar ((kind, body) : mt) : CST.iteratorvar =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_multiline_string_fragment ((kind, body) : mt) : CST.multiline_string_fragment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_3a2a380 (
            trans_pat_3a2a380 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_22cdef7 (
            trans_pat_22cdef7 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_escape_sequence_ ((kind, body) : mt) : CST.escape_sequence_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Imm_tok_bslash_pat_e8ee8e5 (
            trans_imm_tok_bslash_pat_e8ee8e5 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semicolon ((kind, body) : mt) : CST.semicolon =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Auto_semi (
            trans_automatic_semicolon (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false





let trans_marker_annotation ((kind, body) : mt) : CST.marker_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_indexrest ((kind, body) : mt) : CST.indexrest =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Inde_opt_iter (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_indexvar (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_iteratorvar (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Iter_opt_inde (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_iteratorvar (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_indexvar (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_classpath_declaration ((kind, body) : mt) : CST.classpath_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_uses_declaration ((kind, body) : mt) : CST.uses_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_asterisk (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_annotated_type ((kind, body) : mt) : CST.annotated_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Marker_anno (
            trans_marker_annotation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anno_ (
            trans_annotation_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_ ((kind, body) : mt) : CST.annotation_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_annotation_argument_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_argument_list ((kind, body) : mt) : CST.annotation_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Elem_value (
                  trans_element_value (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Opt_elem_value_pair_rep_COMMA_elem_value_pair (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_element_value_pair (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_element_value_pair (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_type_body ((kind, body) : mt) : CST.annotation_type_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Anno_type_elem_decl (
                      trans_annotation_type_element_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Cst_decl (
                      trans_constant_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Class_decl (
                      trans_class_declaration (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Inte_decl (
                      trans_interface_declaration (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Enum_decl (
                      trans_enum_declaration (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Anno_type_decl (
                      trans_annotation_type_declaration (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_type_declaration ((kind, body) : mt) : CST.annotation_type_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            trans_annotation_type_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_type_element_declaration ((kind, body) : mt) : CST.annotation_type_element_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_dimensions (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_default_value (Run.matcher_token v))
              v6
            ,
            Run.trans_token (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Map_init (
                            trans_map_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Array_init (
                                      trans_array_initializer (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Map_init (
                                      trans_map_initializer (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_access ((kind, body) : mt) : CST.array_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_creation_expression ((kind, body) : mt) : CST.array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Inte_type (
                  trans_integral_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Floa_point_type (
                  trans_floating_point_type (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Blk_lit_type (
                  trans_block_literal_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v3 with
            | Alt (0, v) ->
                `Rep1_dimens_expr_opt_dimens (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v -> trans_dimensions_expr (Run.matcher_token v))
                          v0
                        ,
                        Run.opt
                          (fun v -> trans_dimensions (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Dimens_array_init (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_dimensions (Run.matcher_token v0),
                        trans_array_initializer (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_initializer ((kind, body) : mt) : CST.array_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Map_init (
                            trans_map_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Array_init (
                                      trans_array_initializer (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Map_init (
                                      trans_map_initializer (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_type ((kind, body) : mt) : CST.array_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_unannotated_type (Run.matcher_token v0),
            trans_dimensions (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assert_statement ((kind, body) : mt) : CST.assert_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assert_exp_semi (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  trans_semicolon (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Assert_exp_COLON_exp_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_expression (Run.matcher_token v3),
                  trans_semicolon (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Field_access (
                  trans_field_access (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Array_access (
                  trans_array_access (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `PLUSEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `DASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `STAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `SLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `AMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `AMPAMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `BAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `BARBAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `HATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `PERCEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `LTLTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `GTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (13, v) ->
                `GTGTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Array_init (
                  trans_array_initializer (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Map_init (
                  trans_map_initializer (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_GTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_LTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_EQEQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_BANGEQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_BANGEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_LTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_and_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_or_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Exp_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Exp_QMARKPLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Exp_BANGPLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Exp_DASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Exp_QMARKDASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Exp_BANGDASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Exp_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (20, v) ->
          `Exp_QMARKSTAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (21, v) ->
          `Exp_BANGSTAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (22, v) ->
          `Exp_SLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (23, v) ->
          `Exp_QMARKSLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (24, v) ->
          `Exp_AMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (25, v) ->
          `Exp_BAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (26, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (27, v) ->
          `Exp_PERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (28, v) ->
          `Exp_QMARKPERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (29, v) ->
          `Exp_LTLT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (30, v) ->
          `Exp_GTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (31, v) ->
          `Exp_GTGTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block_definition_expression ((kind, body) : mt) : CST.block_definition_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_unannotated_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_unannotated_type (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            (match v5 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block_literal_identifier ((kind, body) : mt) : CST.block_literal_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_fnparameters (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_unannotated_type (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block_literal_type ((kind, body) : mt) : CST.block_literal_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_fnparameters (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_unannotated_type (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block_literal_variable_declaration ((kind, body) : mt) : CST.block_literal_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_block_literal_identifier (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_expression ((kind, body) : mt) : CST.cast_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_type_RPAR_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_expression (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_choice_as_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `As (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Typeas (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_type_ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `LPAR_type_rep_AMP_type_RPAR_choice_prim_exp (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_type_ (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  (match v4 with
                  | Alt (0, v) ->
                      `Prim_exp (
                        trans_primary_expression (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Blk_defi_exp (
                        trans_block_definition_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_catch_formal_parameter (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_block (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Field_decl (
                      trans_field_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Prop_decl (
                      trans_property_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Meth_decl (
                      trans_method_declaration (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Class_decl (
                      trans_class_declaration (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Inte_decl (
                      trans_interface_declaration (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Enum_decl (
                      trans_enum_declaration (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `Static_init (
                      trans_static_initializer (Run.matcher_token v)
                    )
                | Alt (7, v) ->
                    `Cons_decl (
                      trans_constructor_declaration (Run.matcher_token v)
                    )
                | Alt (8, v) ->
                    `Dele_decl (
                      trans_delegate_declaration (Run.matcher_token v)
                    )
                | Alt (9, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_declaration ((kind, body) : mt) : CST.class_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_superclass (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_super_interfaces (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_permits (Run.matcher_token v))
              v6
            ,
            trans_class_body (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_literal ((kind, body) : mt) : CST.class_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unannotated_type (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constant_declaration ((kind, body) : mt) : CST.constant_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_variable_declarator (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_body ((kind, body) : mt) : CST.constructor_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_declaration ((kind, body) : mt) : CST.constructor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_formal_parameters (Run.matcher_token v1),
            trans_constructor_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pack_decl (
            trans_package_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Clas_decl (
            trans_classpath_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Uses_decl (
            trans_uses_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Class_decl (
            trans_class_declaration (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Inte_decl (
            trans_interface_declaration (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Anno_type_decl (
            trans_annotation_type_declaration (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Enum_decl (
            trans_enum_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_value ((kind, body) : mt) : CST.default_value =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_element_value (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dimensions ((kind, body) : mt) : CST.dimensions =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1; v2] ->
              (
                Run.repeat
                  (fun v -> trans_annotation (Run.matcher_token v))
                  v0
                ,
                Run.trans_token (Run.matcher_token v1),
                Run.trans_token (Run.matcher_token v2)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_dimensions_expr ((kind, body) : mt) : CST.dimensions_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_statement ((kind, body) : mt) : CST.do_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_parenthesized_expression (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_value ((kind, body) : mt) : CST.element_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Elem_value_array_init (
            trans_element_value_array_initializer (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Anno (
            trans_annotation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_value_array_initializer ((kind, body) : mt) : CST.element_value_array_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_element_value (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_element_value (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_value_pair ((kind, body) : mt) : CST.element_value_pair =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_element_value (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enhanced_for_statement ((kind, body) : mt) : CST.enhanced_for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Fore (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `For (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            trans_identifier (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_range_expression (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6),
            trans_statement (Run.matcher_token v7),
            trans_semicolon (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_body ((kind, body) : mt) : CST.enum_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_enum_constant (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_enum_constant (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_constant ((kind, body) : mt) : CST.enum_constant =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_argument_list (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            trans_enum_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_eval_statement ((kind, body) : mt) : CST.eval_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Bin_exp (
                  trans_binary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Un_exp (
                  trans_unary_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Tern_exp (
                  trans_ternary_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Prim_exp (
            trans_primary_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Assign_exp (
            trans_assignment_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Typeis_exp (
            trans_typeis_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Blk_defi_exp (
            trans_block_definition_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Tern_exp (
            trans_ternary_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Update_exp (
            trans_update_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Cast_exp (
            trans_cast_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Switch_exp (
            trans_switch_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Type_lit_exp (
            trans_type_literal_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_semicolon (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_extends_interfaces ((kind, body) : mt) : CST.extends_interfaces =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_access ((kind, body) : mt) : CST.field_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Super (
                  trans_super (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `DOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `QMARKDOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `STARDOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `This (
                  trans_this (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_declaration ((kind, body) : mt) : CST.field_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_variable_declarator (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fnparameterdeclaration ((kind, body) : mt) : CST.fnparameterdeclaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v -> trans_annotation_ (Run.matcher_token v))
                  v
              )
              v0
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_unannotated_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fnparameters ((kind, body) : mt) : CST.fnparameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Fnpa (
                            trans_fnparameterdeclaration (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Blk_lit_id (
                            trans_block_literal_identifier (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Fnpa (
                                      trans_fnparameterdeclaration (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Blk_lit_id (
                                      trans_block_literal_identifier (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Fore (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `For (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            trans_identifier (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_expression (Run.matcher_token v5),
            Run.opt
              (fun v -> trans_indexrest (Run.matcher_token v))
              v6
            ,
            Run.trans_token (Run.matcher_token v7),
            trans_statement (Run.matcher_token v8),
            trans_semicolon (Run.matcher_token v9)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter ((kind, body) : mt) : CST.formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_variable_declarator_id (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `COLON_unan_type_opt_EQ_exp (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_unannotated_type (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `EQ_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameters ((kind, body) : mt) : CST.formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_formal_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_formal_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_generic_type ((kind, body) : mt) : CST.generic_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_type_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_guard ((kind, body) : mt) : CST.guard =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interface_body ((kind, body) : mt) : CST.interface_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Cst_decl (
                      trans_constant_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Enum_decl (
                      trans_enum_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Meth_defi (
                      trans_method_defination (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Class_decl (
                      trans_class_declaration (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Inte_decl (
                      trans_interface_declaration (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Anno_type_decl (
                      trans_annotation_type_declaration (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interface_declaration ((kind, body) : mt) : CST.interface_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_extends_interfaces (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_permits (Run.matcher_token v))
              v5
            ,
            trans_interface_body (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_labeled_statement ((kind, body) : mt) : CST.labeled_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Deci_int_lit (
            trans_decimal_integer_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Hex_int_lit (
            trans_hex_integer_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Octal_int_lit (
            trans_octal_integer_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Bin_int_lit (
            trans_binary_integer_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Deci_floa_point_lit (
            trans_decimal_floating_point_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Hex_floa_point_lit (
            trans_hex_floating_point_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Char_lit (
            trans_character_literal (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Infi_lit (
            trans_infinity_literal (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Nan_lit (
            trans_nan_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_variable_declaration ((kind, body) : mt) : CST.local_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_variable_declarator (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_localvarstatement ((kind, body) : mt) : CST.localvarstatement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Unde_pat (
                  trans_underscore_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `COLON_type_opt_choice_as_opt_read_id_opt_EQ_exp (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_type_ (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  (match v0 with
                                  | Alt (0, v) ->
                                      `As (
                                        Run.trans_token (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Typeas (
                                        Run.trans_token (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                  ,
                                  Run.opt
                                    (fun v -> Run.trans_token (Run.matcher_token v))
                                    v1
                                  ,
                                  trans_identifier (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `EQ_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_initializer ((kind, body) : mt) : CST.map_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Map_init (
                            trans_map_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.trans_token (Run.matcher_token v1),
                      (match v2 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Map_init (
                            trans_map_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1; v2; v3] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Array_init (
                                      trans_array_initializer (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Map_init (
                                      trans_map_initializer (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                                ,
                                Run.trans_token (Run.matcher_token v2),
                                (match v3 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Array_init (
                                      trans_array_initializer (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Map_init (
                                      trans_map_initializer (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_declaration ((kind, body) : mt) : CST.method_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_method_header (Run.matcher_token v2),
            trans_block (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_declarator ((kind, body) : mt) : CST.method_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v1
            ,
            trans_fnparameters (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_defination ((kind, body) : mt) : CST.method_defination =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_method_header (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_header ((kind, body) : mt) : CST.method_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_method_declarator (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_unannotated_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_invocation ((kind, body) : mt) : CST.method_invocation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_choice_exp_DOT_id (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Choice_exp (
                              (match v with
                              | Alt (0, v) ->
                                  `Exp (
                                    trans_expression (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Array_init (
                                    trans_array_initializer (Run.matcher_token v)
                                  )
                              | Alt (2, v) ->
                                  `Map_init (
                                    trans_map_initializer (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `Super (
                              trans_super (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v1),
                        trans_identifier (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            trans_argument_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_reference ((kind, body) : mt) : CST.method_reference =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Super (
                  trans_super (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `New (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_modifiers ((kind, body) : mt) : CST.modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Anno (
                trans_annotation (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Priv (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (2, v) ->
              `Inte (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (3, v) ->
              `Prot (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (4, v) ->
              `Public (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (5, v) ->
              `Static (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (6, v) ->
              `Abst (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (7, v) ->
              `Over (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (8, v) ->
              `Final (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (9, v) ->
              `Tran (
                Run.trans_token (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_multiline_string_literal ((kind, body) : mt) : CST.multiline_string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Mult_str_frag (
                      trans_multiline_string_fragment (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq_ (
                      trans_escape_sequence_ (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Str_interp (
                      trans_string_interpolation (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_creation_expression ((kind, body) : mt) : CST.object_creation_expression =
  match body with
  | Children v ->
      trans_unqualified_object_creation_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_object_initializer ((kind, body) : mt) : CST.object_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Unde_pat (
                  trans_underscore_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Array_init (
                  trans_array_initializer (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Map_init (
                  trans_map_initializer (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_package_declaration ((kind, body) : mt) : CST.package_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern ((kind, body) : mt) : CST.pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_pat (
            trans_type_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Record_pat (
            trans_record_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_permits ((kind, body) : mt) : CST.permits =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_update_expression ((kind, body) : mt) : CST.postfix_update_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Tok_plusps (
                  trans_tok_plusplus (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Tok_dash (
                  trans_tok_dashdash (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Class_lit (
            trans_class_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `This (
            trans_this (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Obj_crea_exp (
            trans_object_creation_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Field_access (
            trans_field_access (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Array_access (
            trans_array_access (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Meth_invo (
            trans_method_invocation (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Meth_ref (
            trans_method_reference (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Array_crea_exp (
            trans_array_creation_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Temp_exp (
            trans_template_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_property_declaration ((kind, body) : mt) : CST.property_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Get (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Set (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_identifier (Run.matcher_token v3),
            trans_fnparameters (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_unannotated_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            trans_block (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range_expression ((kind, body) : mt) : CST.range_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_tok_choice_dotdot (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_pattern ((kind, body) : mt) : CST.record_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_record_pattern_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_pattern_body ((kind, body) : mt) : CST.record_pattern_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Record_pat_comp (
                            trans_record_pattern_component (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Record_pat (
                            trans_record_pattern (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Record_pat_comp (
                                      trans_record_pattern_component (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Record_pat (
                                      trans_record_pattern (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_pattern_component ((kind, body) : mt) : CST.record_pattern_component =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Unde_pat (
            trans_underscore_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Unan_type_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_unannotated_type (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_resource ((kind, body) : mt) : CST.resource =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_modifs_unan_type_var_decl_id_EQ_exp (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  trans_unannotated_type (Run.matcher_token v1),
                  trans_variable_declarator_id (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_expression (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Field_access (
            trans_field_access (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_resource_specification ((kind, body) : mt) : CST.resource_specification =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_resource (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_resource (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Exp (
                      trans_expression (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Array_init (
                      trans_array_initializer (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Map_init (
                      trans_map_initializer (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_scoped_type_identifier ((kind, body) : mt) : CST.scoped_type_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v2
            ,
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Decl (
            trans_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_stmt (
            trans_expression_statement (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Labe_stmt (
            trans_labeled_statement (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `If_stmt (
            trans_if_statement (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Enha_for_stmt (
            trans_enhanced_for_statement (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Assert_stmt (
            trans_assert_statement (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Do_stmt (
            trans_do_statement (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Brk_stmt (
            trans_break_statement (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Cont_stmt (
            trans_continue_statement (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Ret_stmt (
            trans_return_statement (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Yield_stmt (
            trans_yield_statement (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Switch_exp (
            trans_switch_expression (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Sync_stmt (
            trans_synchronized_statement (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Local_var_decl (
            trans_local_variable_declaration (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Blk_lit_var_decl (
            trans_block_literal_variable_declaration (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Throw_stmt (
            trans_throw_statement (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Try_stmt (
            trans_try_statement (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Try_with_resous_stmt (
            trans_try_with_resources_statement (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Eval_stmt (
            trans_eval_statement (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Using_stmt (
            trans_using_statement (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Super_stmt (
            trans_super_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_static_initializer ((kind, body) : mt) : CST.static_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_interpolation ((kind, body) : mt) : CST.string_interpolation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_lit_ (
            trans_string_literal_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Mult_str_lit (
            trans_multiline_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal_ ((kind, body) : mt) : CST.string_literal_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_frag (
                      trans_string_fragment (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Str_interp (
                      trans_string_interpolation (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_super_interfaces ((kind, body) : mt) : CST.super_interfaces =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_super_statement ((kind, body) : mt) : CST.super_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_super (Run.matcher_token v0),
            trans_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_superclass ((kind, body) : mt) : CST.superclass =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_block ((kind, body) : mt) : CST.switch_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Rep_switch_blk_stmt_group (
                  Run.repeat
                    (fun v ->
                      trans_switch_block_statement_group (Run.matcher_token v)
                    )
                    v
                )
            | Alt (1, v) ->
                `Rep_switch_rule (
                  Run.repeat
                    (fun v -> trans_switch_rule (Run.matcher_token v))
                    v
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_block_statement_group ((kind, body) : mt) : CST.switch_block_statement_group =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_switch_label (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression ((kind, body) : mt) : CST.switch_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_switch_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_label ((kind, body) : mt) : CST.switch_label =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Case_choice_pat_opt_guard (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Pat (
                        trans_pattern (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exp_rep_COMMA_exp (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              trans_expression (Run.matcher_token v0),
                              Run.repeat
                                (fun v ->
                                  (match v with
                                  | Seq [v0; v1] ->
                                      (
                                        Run.trans_token (Run.matcher_token v0),
                                        trans_expression (Run.matcher_token v1)
                                      )
                                  | _ -> assert false
                                  )
                                )
                                v1
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_guard (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Defa (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_rule ((kind, body) : mt) : CST.switch_rule =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_switch_label (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Exp_stmt (
                  trans_expression_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Throw_stmt (
                  trans_throw_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_synchronized_statement ((kind, body) : mt) : CST.synchronized_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_template_expression ((kind, body) : mt) : CST.template_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_string_literal (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ternary_expression ((kind, body) : mt) : CST.ternary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_statement ((kind, body) : mt) : CST.throw_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Rep1_catch_clause (
                  Run.repeat1
                    (fun v -> trans_catch_clause (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `Rep_catch_clause_fina_clause (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat
                          (fun v -> trans_catch_clause (Run.matcher_token v))
                          v0
                        ,
                        trans_finally_clause (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_with_resources_statement ((kind, body) : mt) : CST.try_with_resources_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_resource_specification (Run.matcher_token v1),
            trans_block (Run.matcher_token v2),
            Run.repeat
              (fun v -> trans_catch_clause (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_finally_clause (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Unan_type (
            trans_unannotated_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anno_type (
            trans_annotated_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Type (
                            trans_type_ (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Wild (
                            trans_wildcard (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Type (
                                      trans_type_ (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Wild (
                                      trans_wildcard (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_bound ((kind, body) : mt) : CST.type_bound =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_list ((kind, body) : mt) : CST.type_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_literal_expression ((kind, body) : mt) : CST.type_literal_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Typeof (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Stat (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_parenthesized_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_bound (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_pattern ((kind, body) : mt) : CST.type_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_unannotated_type (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typeis_expression ((kind, body) : mt) : CST.typeis_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `Type_opt_id (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_type_ (Run.matcher_token v0),
                        Run.opt
                          (fun v -> trans_identifier (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Record_pat (
                  trans_record_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unannotated_type ((kind, body) : mt) : CST.unannotated_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_void_type (
            (match v with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Inte_type (
                  trans_integral_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Floa_point_type (
                  trans_floating_point_type (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Blk_lit_type (
                  trans_block_literal_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Array_type (
            trans_array_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Not_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Typeof_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Stat_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Post_update_exp (
            trans_postfix_update_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unqualified_object_creation_expression ((kind, body) : mt) : CST.unqualified_object_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Rep_anno_type_args_rep_anno (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.repeat
                          (fun v -> trans_annotation (Run.matcher_token v))
                          v0
                        ,
                        trans_type_arguments (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_annotation (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Rep_anno (
                  Run.repeat
                    (fun v -> trans_annotation (Run.matcher_token v))
                    v
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Inte_type (
                  trans_integral_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Floa_point_type (
                  trans_floating_point_type (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Blk_lit_type (
                  trans_block_literal_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Opt_obj_init_rep_COMMA_obj_init (
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_object_initializer (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.trans_token (Run.matcher_token v0),
                                                trans_object_initializer (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v
                          )
                      | Alt (1, v) ->
                          `Opt_meth_decl_rep_COMMA_meth_decl (
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_method_declaration (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.trans_token (Run.matcher_token v0),
                                                trans_method_declaration (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_update_expression ((kind, body) : mt) : CST.update_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_PLUSPLUS (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_DASHDASH (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_using_statement ((kind, body) : mt) : CST.using_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Loca_rep_COMMA_loca (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_localvarstatement (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_localvarstatement (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_block (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_finally_clause (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declarator ((kind, body) : mt) : CST.variable_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Unde_pat (
                  trans_underscore_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `COLON_unan_type_opt_choice_as_opt_read_id_opt_EQ_choice_exp (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_unannotated_type (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  (match v0 with
                                  | Alt (0, v) ->
                                      `As (
                                        Run.trans_token (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Typeas (
                                        Run.trans_token (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                  ,
                                  Run.opt
                                    (fun v -> Run.trans_token (Run.matcher_token v))
                                    v1
                                  ,
                                  trans_identifier (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Exp (
                                        trans_expression (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Array_init (
                                        trans_array_initializer (Run.matcher_token v)
                                      )
                                  | Alt (2, v) ->
                                      `Map_init (
                                        trans_map_initializer (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `EQ_choice_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Exp (
                              trans_expression (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Array_init (
                              trans_array_initializer (Run.matcher_token v)
                            )
                        | Alt (2, v) ->
                            `Map_init (
                              trans_map_initializer (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declarator_id ((kind, body) : mt) : CST.variable_declarator_id =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Unde_pat (
                  trans_underscore_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_dimensions (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_wildcard ((kind, body) : mt) : CST.wildcard =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_wildcard_bounds (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_wildcard_bounds ((kind, body) : mt) : CST.wildcard_bounds =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Extends_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yield_statement ((kind, body) : mt) : CST.yield_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false









let trans_enhancement_body ((kind, body) : mt) : CST.enhancement_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_method_declaration (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false




let trans_enhancement_declaration ((kind, body) : mt) : CST.enhancement_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_unannotated_type (Run.matcher_token v4),
            trans_enhancement_body (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_toplevel_statement ((kind, body) : mt) : CST.toplevel_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Stmt (
            trans_statement (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Meth_decl (
            trans_method_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Enha_decl (
            trans_enhancement_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_program ((kind, body) : mt) : CST.program =
  match body with
  | Children v ->
      Run.repeat
        (fun v -> trans_toplevel_statement (Run.matcher_token v))
        v
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "line_comment" ->
      (match translate_tree src node trans_line_comment with
      | None -> None
      | Some x -> Some (`Line_comment (Run.get_loc node, x)))
  | "block_comment" ->
      (match translate_tree src node trans_block_comment with
      | None -> None
      | Some x -> Some (`Block_comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_program

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

